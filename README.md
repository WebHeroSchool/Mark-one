### Создание переменной 
---
- Пробелы применяются для разделения символов или для создания комментариев
- Для объявления переменной используйте ключевые слова: `let`, `const`.
- Переменные, которые не имеют данных нужно просто добавить без дополнительных записей.

:-1: Так лучше не делать:
```
let a = undefined;
```

### Имя переменной
---
- Имя переменной может состоять из 1 и более буков
- Имя должно содержать только буквы, цифры или символы `$` и `_`.
- Первый символ не должен быть цифрой.
- Если имя содержит несколько слов,то для объявления переменной использовать метод camelCase
- Переменную не называть зарезервированными словами JS (`for`, `if`, `else`, `while`)



### Фигурные скобки
---
Фигурные скобки пишутся в так называемом «египетском» стиле с открывающей скобкой на той же строке, что и соответствующее ключевое слово – не на новой строке. Перед открывающей скобкой должен быть пробел.
```
if (condition) {
// делай это 
// ...и это
// ...и потом это
}
```
Разные типы расстоновок фигурных скобок
1. :-1: Плохо, фигурные скобки не нужны:
```
if (n < 0) {alert(`Степень ${n} не поддерживается`);}
```

2. :-1:Никогда не разделяйте строки без фигурных скобок, можно ненароком сделать ошибку при добавлении строк:
```
if (n < 0)
alert(`Степень ${n} не поддерживается`);
```

3. :+1: В одну строку без скобок – приемлемо, если эта строка короткая:
```
if (n < 0) alert(`Степень ${n} не поддерживается`);
```

4. Самый лучший вариант:
```
if (n < 0) {
  alert(`Степень ${n} не поддерживается`);
}
```
Для очень короткого кода допустима одна строка. Например: `if (cond) return null`. Но блок кода (последний вариант) обычно всё равно читается лучше.

### Точка с запятой
---
Не забывайте ставить точку с запятой в конце каждой операции.

```
let age = prompt("Сколько Вам лет?", 18);
let welcome;

if (age < 18) {
  welcome = function() {
    alert("Привет!");
  };
} else {
  welcome = function() {
    alert("Здравствуйте!");
  };
}
welcome();
```

### Объекты
---
Для объявления объекта рекомендуется использовать фигурные скобки

```
let user = {     
  name: "John", 
  age: 33        
};
```

### Массивы
---
Для объявления массивов следует использовать квадратные скобки или конструктор **new Array**
```
let items = ["item1", "item2", "item3"];
let arr = new Array();
```

### Длина строки
---
Никто не любит читать длинные горизонтальные строки кода. Лучше всего разбивать их, например:
```
// обратные кавычки ` позволяют разделять строку на части
let str = `
  Рабочая группа TC39 организации Ecma International -
  это группа JavaScript-разработчиков, теоретиков и авторов движков JavaScript,
  которые вместе с сообществом занимаются поддержкой и развитием языка JavaScript.
`;
```

Или для if:
```
if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
```
Максимальную длину строки согласовывают в команде. Обычно это 80 или 120 символов.

### Уровни вложенности
---
Уровней вложенности должно быть немного.

Например, в цикле бывает полезно использовать директиву `continue`, чтобы избежать лишней вложенности.

Например, вместо добавления вложенного условия if, как здесь:
```
for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- ещё один уровень вложенности
  }
}
```

Мы можем написать:
```
for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- нет лишнего уровня вложенности
}
```
Аналогичная ситуация – с `if/else` и `return`.

Например, две нижеследующие конструкции идентичны.

Первая:
```
function pow(x, n) {
  if (n < 0) {
    alert("Отрицательные значения 'n' не поддерживаются");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
```

Вторая:
```
function pow(x, n) {
  if (n < 0) {
    alert("Отрицательные значения 'n' не поддерживаются");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

Второй вариант является более читабельным, потому что «особый случай» n < 0 обрабатывается на ранней стадии. После проверки можно переходить к «основному» потоку кода без необходимости увеличения вложенности.

### Отступы
---
Существует два типа отступов:

- Горизонтальные отступы: два или четыре пробела. 

	Горизонтальный отступ выполняется с помощью 2 или 4 пробелов, или символа табуляции (клавиша `Tab`). Какой из них выбрать – это уже на ваше усмотрение. Пробелы больше распространены.
	
	Одно из преимуществ пробелов над табуляцией заключается в том, что пробелы допускают более гибкие конфигурации отступов, чем символ табуляции.

	Например, мы можем выровнять аргументы относительно открывающей скобки:
```
show(parameters,
     aligned, // 5 пробелов слева
     one,
     after,
     another
  ) {
  // ...
}
```

- Вертикальные отступы: пустые строки для разбивки кода на «логические блоки».

	Даже одну функцию часто можно разделить на логические блоки. В примере ниже разделены инициализация переменных, основной цикл и возвращаемый результат:
```
function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
```

	Вставляйте дополнительный перевод строки туда, где это сделает код более читаемым. Не должно быть более 9 строк кода подряд без вертикального отступа.

### Размещение функций
---

Если вы пишете несколько вспомогательных функций, а затем используемый ими код, то существует три способа организации функций.

1.Объявить функции перед кодом, который их вызовет:
```
// объявление функций
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// код, который использует их
let elem = createElement();
setHandler(elem);
walkAround();
```

2.Сначала код, затем функции
```
// код, использующий функции
let elem = createElement();
setHandler(elem);
walkAround();

// --- вспомогательные функции ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
```
3.Смешанный стиль: функция объявляется там, где она используется впервые.

В большинстве случаев второй вариант является предпочтительным.

Это потому, что при чтении кода мы сначала хотим знать, что он делает. Если сначала идёт код, то это тут же становится понятно. И тогда, может быть, нам вообще не нужно будет читать функции, особенно если их имена хорошо подобраны.


